{"/":{"title":"_index","content":"# CTF Wiki\n\nCapture The Flags, or CTFs, are a kind of computer security competition.\n\nTeams of competitors (or just individuals) are pitted against each other in a test of computer security skill.\n\nVery often CTFs are the beginning of one's cyber security career due to their team building nature and competetive aspect. In addition, there isn't a lot of commitment required beyond a weekend.\n\nIn this guide/wiki/handbook you'll learn the techniques, thought processes, and methodologies you need to succeed in Capture the Flag competitions.\n\nFor the basics about how to play in a CTF, go [[basics|here]] first.\n\nFor general information about CTFs, go [[general|here]].\n\nFor solving MCPSHSF challenges on a chromebook, go [[chromebooks|here]].\n\nFor information about specific categories of challenges:\n* [[forensics/intro|Forensics]]\n* [[crypto/intro|Cryptography]]\n* [[linux/intro|Linux]]","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/basics":{"title":"basics","content":"When playing a CTF, you are on the look out for *flags*. A flag usually looks something like this:\n\n```\nflag{some_message}\n```\n\nThere is a standardized format of `flag{...}` where the inside of the brackets can have any message inside of it. \n\nWhen you find one of these flags, go to the competition website to enter it.\n\nIf you want to enter evidence that is not a flag, please uncheck the \"Submitting a flag \" box as shown below:\n![enter flag](/images/enterflag.png)","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/chromebooks":{"title":"Solving MCPSHSF on a Chromebook","content":"Although it is possible to solve MCPSHSF challenges on a Chromebook, it is difficult. This is because Chromebooks do not support the use of virtual machines, which are necessary for solving many challenges. However, there are some ways to solve challenges on a Chromebook. In this guide, we will go over the different ways to solve challenges on a Chromebook.\n\n## Using a Linux VM\nWe provide a Linux VM that you can use to solve challenges on a Chromebook. This VM is based on Ubuntu and is preconfigured with all the tools you need to solve MCPSHSF challenges. You can also install any other tools you need with `apt`. The url to your team's VM is listed on the team page. The password is also listed there.\n\n## Web Tools\nThere are some web tools that you can use to solve challenges on a Chromebook. These tools are not as powerful as the VM, but they can still be used to solve challenges. The web tools are listed below:\n* [CyberChef](https://gchq.github.io/CyberChef/)\n* [Spectrogram Viewer](https://academo.org/demos/spectrum-analyzer/)\n* [Metadata Viewer](https://www.geekyhumans.com/tools/image-metadata-viewer)\n* [Steghide](https://futureboy.us/stegano/decinput.html)\n* [Hex Editor](https://hexed.it/)\n* [Cloudshark](https://www.qacafe.com/analysis-tools/cloudshark/)\n    * Used for viewing pcap files\n* [Replit](https://replit.com/)\n    * Used for coding quick scripts in Python\n* [LSB Steganography](https://stylesuxx.github.io/steganography/)\n* [Git Visualizer](https://github.com)\n    * Create a new repository and upload your files to it. Then, go to the Insights tab and click on the Network tab. This will show you a visual representation of the commits you made to the repository.\n\n## Stipulations\nUnfortunately, memory forensics challenges cannot be solved on a Chromebook. This is because there are no web tools that can be used to solve memory forensics challenges. Also, some challenges cannot be solved using web tools, and must be solved using CLI tools. However, you can still solve these challenges using the desktop provided to your Team.","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/crypto/ciphers":{"title":"Ciphers","content":"\n## Substitution Ciphers\n\n### What is a Substitution Cipher?\n\nA Substitution cipher is a way of encrypting data, where every occurrence of specific letter from the alphabet within the plaintext you supply, is substituted by another character from the alphabet. This encrypted series of characters is given to the recipient, who knows what the character substitutions are and can reverse the process to get the plaintext back again.\n\nFor example:\n\n```\nA = X\nB = D\nC = H\nD = S\n... (and so on)\n```\n\nThe key here is the arrangement of letters mapped to the original. If you possess the above key (in full) then returning the data to the original plaintext (decryption) is trivial - simply reverse it. There may be more complex substitution methods, for example, pairs of characters AB = MK rather than singles, but the above is a common and simple method.\n\nYou can also apply the same logic to bytes. If the same substitution is used throughout the message the cipher is referred to as monoalphabetic, whereas a polyalphabetic cipher uses a number of substitutions at different positions in the message.\n\n### Breaking a Substitution Cipher\n\nBreaking a substitution cipher is relatively easy, as long as you have a large enough sample of the ciphertext. The most common method is to use a frequency analysis of the ciphertext, and compare it to the frequency of letters in the English language. The most common letters in the English language are E, T, A, O, I, N, S, H, R, D, L, C, U, M, W, F, G, Y, P, B, V, K, J, X, Q, Z. If you have a large enough sample of the ciphertext, you can compare the frequency of letters in the ciphertext to the frequency of letters in the English language, and work out which letters are most likely to be which. For example, if you have a large sample of ciphertext, and the letter E is the most common, then you can assume that the most common letter in the plaintext is E. You can then work out the second most common letter, and so on.\n\nAnother method is to use a crib dragging attack. This is where you take a known plaintext, and drag it across the ciphertext, and compare the results. For example, if you know that the plaintext is \"I love you\", and you drag it across the ciphertext, you can see that the most common letters are \"I\", \" \", \"l\", \"o\", \"v\", \"e\", \"y\", \"u\". You can then use this information to work out the most common letters in the ciphertext, and work out the key.\n\n\u003e These ciphers can be broken quite easily, so they are not used in real-world applications. \n\n## Caesar or ROT Cipher\n\n### What is a Caesar Cipher?\n\nThe Caesar cipher is a substitution cipher where each letter in the plaintext is replaced by a letter a fixed number of positions down the alphabet. For example, if the shift is 3, then A becomes D, B becomes E, C becomes F, and so on. The shift is the number of positions down the alphabet that each letter is replaced by. The shift can be any number between 1 and 25, and is usually referred to as the key. It is named after Julius Caesar, who used it to communicate with his generals. It also has other names, including ROT (for \"rotate\") and shift cipher.\n\nFor example\n```\noffset = 13\nT + 13 = G\nE + 13 = R\nS + 13 = F\nT + 13 = G\nI + 13 = V\nN + 13 = A\nG + 13 = T\n```\n\n### Breaking a Caesar Cipher\n\nBecause are only 26 possible keys, it is possible to brute force a Caesar cipher. This means that you can try every possible key, and see which one produces the most readable plaintext. This is a very simple method, and can be done by hand, or by a computer. The Caesar Cipher is not very secure, and is not used in real-world applications.\n\n## Vigenere Cipher\n\n### What is a Vigenere Cipher?\n\nThe Vigenere cipher is a substitution cipher that uses a series of Caesar ciphers based on the letters of a keyword. It is a form of polyalphabetic substitution. Each letter of the keyword is treated as a Caesar cipher with a shift value of its alphabetical position. Non-alphabetical characters are ignored. For example, if the keyword is \"TRAIN\", then the first letter, T, is shifted by 20 places, the second letter, R, by 18 places, and so on. Punctuation, spaces and numbers are left as is and are not encoded. This means that the key must be repeated for the length of the message, or be at least as long as the message. For example, if the message is \"HELLO WORLD\", and the key is \"TRAIN\", then the key would be repeated to form \"TRAINTRAINT\". The ciphertext would be \"EIOZC ZRCEG\".\n\n### Breaking a Vigenere Cipher\n\nThe Vigenere cipher is much more secure than the Caesar cipher, but can still be broken by frequency analysis. Because the Vigenere cipher uses multiple Caesar ciphers, it is possible to break each one individually, and then work out the key. This is known as a Kasiski examination. This is a very complex method, and is not covered in here. However, there are a number of online tools that can do this for you. One such tool is [quipqiup](http://quipqiup.com/).\n\n","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/crypto/encoding":{"title":"Encoding","content":"\n## ASCII\n\nASCII or the American Standard Code for Information Interchange is an encoding scheme designed to represent simple text characters on computers. When a computer stores (or transmits) data, it fundamentally does so in binary: a sequence of 1s and 0s (or high/low voltage on a wire). ASCII provides a means of mapping those binary values to characters we understand. It acts as a way to translate our preferred method to read and write information (letters, numbers, symbols etc) to the way a computer prefers (binary). This is primarily done via a \"lookup table\". \n\nFor example, the ASCII character \"A\" is represented by the binary value 01000001. The ASCII character \"B\" is represented by the binary value 01000010. The ASCII character \"C\" is represented by the binary value 01000011. And so on. \n\nASCII not only provides a way to represent the 26 letters of the English alphabet, but also numbers, punctuation, and other symbols. It also provides a way to represent \"control characters\" such as carriage return, line feed, and tab.\n\nBut what about other languages? What about emojis? What about other symbols? ASCII is limited in its ability to represent all of the characters we may want to use. In order to represent more characters, we need to use a different table, such as the [Unicode](https://en.wikipedia.org/wiki/Unicode) table. Unicode is a superset of ASCII, and includes all of the characters that ASCII can represent, plus many more.\n\n## Hexadecimal\n\nHexadecimal (otherwise known as hex) is hugely important in computer science and cyber security, especially on offensive tasks, hacking and defensive roles like forensics. Typically, in everyday life we use a base 10 numbering system (aka Decimal), that is; numbers 0 - 9. Hexadecimal however is base 16 (think of \"hex\" being 6, like hexagon and \"decimal\" being 10, like decade ... 6 + 10 = 16). A base 16 system stores values in a more space efficient and easy to process way for computers. For example, 10 in decimal is reprsented by 1010 in binary and A in hexadecimal. \n\nHaving data in hex format doesn't change the underlying data, it is just a more efficient way of communicating that data. For this reason it's often used as a means of encoding and sometimes computers will convert data to hexadecimal before transmitting it. A lot of web applications will do this, for example.\n\nIf you want to convert data to or from other formats quickly and easily, there's some great online tools available. Simply just search for what you'd like to achieve and there will be a range of great tools ready to covert data for you.\n\nThere's some great hex editing tools to make use of if you need to do more than just a quick conversion. [HxD](https://mh-nexus.de/en/hxd/) is a great free tool for Windows, and [Hex Fiend](https://ridiculousfish.com/hexfiend/) is a great free tool for Mac. If you want an online tool, [HexEdit](https://hexed.it/) is a great option.\n\n### Base64 and Base32\n\nBase64 is a common encoding scheme for converting complex data to a simple text based format. Like any encoding scheme, it can be both encoded and then decoded back to the original data, but in its encoded form can be easier to store or transfer, especially in more restrictive scenarios where only text is feasible to use.\n\nOne example may be an embedded image in an email; you shouldn't store the binary data of the image file in the email file (typically .eml or .msg format) as the email file format needs to contain just text contents only. In this case you'd encode the image file as Base64, so it's in simple text only format and that's then fine to store in an email file.\n\nAnother example may be when you've gained access to a server and need to extract a file but transfer means such as SCP aren't available. Copying \u0026 pasting file contents may be a quick solution, but if you display binary data, copy that and paste it to a new file on your local machine, it very likely won't result in a working file as not all machine-readable data is displayable and so some data will be lost in transfer.\n\nInstead, the contents can be displayed in Base64 encoding, copied and pasted into a new file on your local machine and finally decoded back to the original binary format. This is much less likely to fail as during transfer (copying \u0026 pasting to your clipboard) as you are dealing with just simple text (Base64 contents), avoiding the original problem.\n\nBase64 and Base32 are not encryption. They're not meant to obfuscate or obscure data from a potential reader, they simply transform data into a different format for storage or transfer. There are many websites, command line tools and code modules which facilitate conversion to and from Base64. For example, on the Linux command line, you can use the base64 command to encode data quickly as follows:\n\n```shell\n$ echo \"How are you today?\" | base64\nSG93IGFyZSB5b3UgdG9kYXk/Cg==\n```\nAs you can see in the example above, a common way of spotting Base64 encoded data is trailing `=` characters at the end (there may be 0 - 2 of these!). This is because part of encoding the original data is to split data into 24 bit chunks, and if the chunk is shorter than 24 bits the data is 'padded' to fill in the gap, possibly resulting in the '=' characters you see - they're \"filler\". Another indication is if it contains alphanumeric characters (plus `+` or `/` characters) as mentioned previously.","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/crypto/encryption":{"title":"Encryption","content":"\n## Encryption v.s Encoding\n\nEncryption and encoding are often confused. Encoding is a way to convert data from one format to another. For example, you can encode a string of text into a base64 string. Encoding is reversible, and is often used to make data more portable. Encoding is not secure, and should not be used to protect sensitive data. \n\n## XOR Encryption\n\nThe XOR cipher uses... you guessed it, the XOR (exclusive or). Much like other ciphers, you’ll have three components - the plaintext, the ciphertext and the key. One of the great properties of XOR is that if you have the 3 components, and you XOR any two, you can produce the other one. This somewhat naturally produces an encryption and decryption mechanism. This also provides reasonable security because if you have 1 of the 3 parts it is very hard to guess the other 2 correctly!\n\nLet us look at an example by first reminding ourselves how XOR works:\n```\n0 XOR 0 = 0\n0 XOR 1 = 1\n1 XOR 0 = 1\n1 XOR 1 = 0\n```\nThis is the basis of the XOR cipher. The cipher works by taking the plaintext and XORing it with the key. This produces the ciphertext. To decrypt the ciphertext, you XOR it with the key again. This produces the plaintext again.\n\nIn this example, the plaintext is `HEY` and the key is `KEY`. When converting the plaintext and key to binary, we get the following:\n```\nHEY = 01001000 01000101 01011001\nKEY = 01001011 01011001 01011001\n```\nNow we can XOR the plaintext with the key to get the ciphertext:\n```\nCiphertext = 00000011 00011100 00000000\n```\n\nTo do XOR encryption and decryption, you can use an online tool like [CyberChef](https://gchq.github.io/CyberChef/). With a small enough key, you can brute force the key and decrypt the ciphertext. However, with a large enough key, this becomes infeasible.\n\n## Symmetric Encryption\n\nThis is a big topic! Encryption supports most modern applications and websites, as well as most of the technology around you. At this point in your study, we don't want to get too far in to encryption at the modern day working level, but let's cover some key concepts and show how you can encrypt and decrypt some data with strong encryption.\n\nSymmetric encryption is where a key is used for both encryption and decryption. This same key can be used to encrypt and then decrypt. It is ideal in a scenario where I want to encrypt data, retain the key as a secret, and then decrypt later. Of course, I could also share it with another party via some out of bands mechanism to make sure the key is kept safe.\n\nThe most common symmetric encryption algorithm is AES. AES stands for Advanced Encryption Standard. It is a symmetric block cipher that can encrypt and decrypt data in blocks of 128 bits. AES is a very strong encryption algorithm, and is used in many applications. It is also used in the TLS protocol to encrypt data in transit.\n\n[CyberChef](https://gchq.github.io/CyberChef/) has a great AES implementation. You can use it to encrypt and decrypt data. You can also encrypt and decrypt data using the `openssl` command line tool. You can use the following command to encrypt `coolfile.jpg` using AES-256-CBC:\n```shell\n$  openssl enc -aes256 -base64 -in coolfile.jpg -out coolfile.enc\nenter aes-256-cbc encryption password:\nVerifying - enter aes-256-cbc encryption password:\n```\nYou can then decrypt the file using the following command:\n```shell\n$  openssl enc -d -aes256 -base64 -in coolfile.enc -out coolfile.jpg\nenter aes-256-cbc decryption password:\n```\n\n## Asymmetric Encryption\n\nAsymmetric encryption is where you have two keys - a public key and a private key. The public key can be shared with anyone, and the private key should be kept secret. The public key is used to encrypt data, and the private key is used to decrypt data. The private key is used to sign data, and the public key is used to verify the signature. This is a very common scenario in the real world. For example, you can use asymmetric encryption to encrypt data that only you can decrypt. You can also use asymmetric encryption to sign data, and then verify the signature using the public key.\n\nThe most common asymmetric encryption algorithm is RSA. RSA is a public key encryption algorithm. RSA is a very strong encryption algorithm, and is used in many applications. It is often used to encrypt data in transit, and to sign data.\n\nRSA is a bit more complicated than AES, so we won't go into too much detail here. Reading the [Wikipedia article](https://en.wikipedia.org/wiki/RSA_(cryptosystem)) is a good place to start. \n\n","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/crypto/hashing":{"title":"Hashing","content":"\n## What is Hashing?\n\nHashing is a super neat example of cryptography, with many important uses in data integrity. The algorithm used when hashing takes any input data (known as the plaintext) - such as a message, a file, a password - and produces a fixed size ciphertext; which is a hash value, most commonly referred to has a hash.\n\nThere are a few important properties that make up a strong algorithm:\n\nHashing algorithms should be one way, meaning it should not be possible to reverse the recipe to reproduce the original plaintext data. Additionally, the same input should always result in the same output - it is deterministic. This makes hashes a great way to store some sort of data that we don't need to decrypt, instead only using that hash value for validation needs at a future point in time.\n\nFor example, when a user registers at a site, the password provided is hashed and stored in a database. When the user returns in the future to login, the password they now provide will be also hashed using the same algorithm that originally produced the stored hash. The stored hash and this new hash are compared and if they match, the provided password must be correct! The plaintext is not (and should not ever!) be stored in the database. This gives safety in-case the database is ever breached, yet still allows for a safe \u0026 functioning login system.\n\nIn hashing algorithms, a small change in the plaintext data should result in significantly different output, reducing the likelihood an attacker is able to predict the outcome of the algorithm and in doing so, 'break' it. This is known as the avalanche effect.\n\nHashing algorithms should be collision reistant, meaning that it is difficult to produce two matching ciphertext for different pieces of plaintext data. A crytpographic hash is weaker and less useful if it is not unique to the plaintext provided.\n\nAnother common use is validating file contents. We can produce a hash value for a file and use this to validate whether a file has been modified since - if the file contents are different, the resulting hash will not match.\n\n## Examples\nHere's a couple of examples hashing the string `password123` in popular hashing algorithms; MD5 and SHA-1:\n```shell\n$ echo -n \"password123\" | md5sum\n482c811da5d5b4bc6d497ffa98491e38\n\n$ echo -n \"password123\" | shasum\ncbfdac6008f9cab4083784cbd1874f76618d2a97\n```\n\n## Breaking Hashes\n\nHashing algorithms are designed to be one-way, meaning that it is not possible to reverse the recipe to reproduce the original plaintext data. However, there are some ways to 'break' a hash, and in doing so, find the original plaintext data. \n\nIf the user chooses a weak password, such as `password123`, it is possible to use a dictionary attack to find the plaintext data. This is where a list of common passwords is used to try and match the hash value. If the hash matches, the password is found.\n\nBrute force tools like [John the Ripper](https://www.openwall.com/john/) and [Hashcat](https://hashcat.net/hashcat/) can also be used to try and find the plaintext data. These tools can be used to try and find the plaintext data by trying every possible combination of characters, and comparing the hash value to the hash value of the plaintext data. If the hash matches, the password is found.","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/crypto/intro":{"title":"Crypto Intro","content":"\nCryptography is the practice of securing communication from third-party access, ensuring that only the intended recipient can access the message. It involves the use of mathematical algorithms to encode and decode information, converting it into a secret code that is unreadable to anyone except the intended recipient.\n\nSome terminology you may find helpful as you proceed:\n\n- **Encryption.** A process and method which takes plaintext and produces ciphertext that can be sent to another party, or stored. This often requires a key.\n- **Decryption.** A process and method which takes ciphertext, and produces plaintext. This often requires a key to be shared so that you can retrieve the plaintext data.\n- **Encoding.** A process and method which takes plaintext and produces ciphertext that can be sent to another party, or stored. This does not require a key.\n- **Key.** A piece of information (typically a string of letters, numbers etc) which is used as part of an encryption and decryption process. Depending on the cipher, different requirements may exist for the key in size or structure. Sometimes different keys are used to encrypt/decrypt, which we will learn about later.\n- **Cipher.** An algorithm for performing encryption or decryption. Essentially a recipe that can be followed to produce the result. The cipher typically requires a key and the combination can transform plaintext to ciphertext, or back.\n- **Hashing.** This is where a plaintext input has a hashing algorithm applied to it, to produce a fixed length output of seemingly random, but always repeatable output if you follow the same steps. Most commonly used to validate data such as identity.\n\nMain Concepts:\n* [[cipher|Ciphers]]\n* [[hashing|Hashing]]\n* [[encoding|Encoding]]\n* [[encryption|Encryption]]\n","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/forensics/asking-forensics-questions":{"title":"asking-forensics-questions","content":"# Asking Forensics Questions\n\nSo you are looking at some piece of **evidence**. **Evidence** could be anything from a website, to an image, to even simply a piece of text. With forensics, it is all about asking the right questions and looking for the answers. For example, lets take a look at this piece of text:\n\n\u003e aGFoYSB5b3UgZm91bmQgbWUh\n\nLooks pretty weird right? If you didn't know what you were looking at, it can be pretty confusing. Luckily, there are tools that exist that can help us get some ideas quickly. [CyberChef](https://gchq.github.io/CyberChef/#recipe=To_Base64('A-Za-z0-9%2B/%3D')\u0026input=aGFoYSB5b3UgZm91bmQgbWUh) is a great tool and in this case helps us out! We can drag and drop different filters to discover that this text was encoded with [Base64](https://en.wikipedia.org/wiki/Base64).\n\n\u003e haha you found me!\n\n## Text\n- Are there patterns to the characters that I am looking at?\n\t- [Common text encoding formats](https://en.wikipedia.org/wiki/Binary-to-text_encoding)\n\n## Image\n- What metadata exists on the image?\n\t- Author\n\t- GPS Coordinates\n- Is there any content hidden inside of the image as text?\n- Can I do a [reverse image search](https://images.google.com/) to find the original image?\n- Could there be [[what-is-steganography|steganography]] hidden in the image?\n\n## Website\n- ","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/forensics/intro":{"title":"Forensics Intro","content":"\nForensics is the art of recovering the digital trail left on a computer. There are plently of methods to find data which is seemingly deleted, not stored, or worse, covertly recorded.\n\nIt can be difficult to figure out how to navigate evidence. [[asking-forensics-questions|Here are some questions]] you can ask as you come across new evidence.\n\nAn important part of Forensics is having the right tools, as well as being familair with the following topics:\n* [[what-is-a-hex-editor|What is a hex editor?]]\n* [[what-is-memory-forensics|What is memory forensics?]]\n* [[what-are-file-formats|What are File Formats?]]\n* [[what-is-metadata|What is Metadata?]]\n* [[what-is-wireshark|What is Wireshark?]]\n* [[what-is-steganography|What is Steganography?]]\n* [[what-is-disk-imaging|What is Disk Imaging?]]\n\nFor more tools and information about forensics, check out these resources:\n- https://trailofbits.github.io/ctf/forensics/\n\t- Great introduction\n- [Awesome Forensics](https://github.com/cugu/awesome-forensics)\n\t- A wide collection of different tools to look at","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/forensics/what-are-file-formats":{"title":"What are file formats?","content":"\nFile Extensions are not the sole way to identify the type of a file, files have certain leading bytes called *file signatures* which allow programs to parse the data in a consistent manner. Files can also contain additional \"hidden\" data called *metadata* which can be useful in finding out information about the context of a file's data.\n\n## File Signatures\n\n**File signatures** (also known as File Magic Numbers) are bytes within a file used to identify the format of the file. Generally they’re 2-4 bytes long, found at the beginning of a file.\n\n### What is it used for?\n\nFiles can sometimes come without an extension, or with incorrect ones. We use file signature analysis to identify the format (file type) of the file. Programs need to know the file type in order to open it properly.\n\n### How do you find the file signature?\n\nYou need to be able to look at the binary data that constitutes the file you’re examining. To do this, you’ll use a hexadecimal editor. Once you find the file signature, you can check it against file signature repositories [such as Gary Kessler’s](http://www.garykessler.net/library/file_sigs.html).\n\n### Example\n\n![File A](/images/file-a.jpg)\n\nThe file above, when opened in a Hex Editor, begins with the bytes `FFD8FFE0 00104A46 494600` or in ASCII `ˇÿˇ‡  JFIF` where `\\x00` and `\\x10` lack symbols. \n\nSearching in [Gary Kessler’s](http://www.garykessler.net/library/file_sigs.html) database shows that this file signature belongs to a `JPEG/JFIF graphics file`, exactly what we suspect.\n","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/forensics/what-is-a-hex-editor":{"title":"What is a hex editor?","content":"\nA hexadecimal (hex) editor (also called a binary file editor or byte editor) is a computer program you can use to manipulate the fundamental binary data that constitutes a computer file. The name “hex” comes from “hexadecimal,” a standard numerical format for representing binary data. A typical computer file occupies multiple areas on the platter(s) of a disk drive, whose contents are combined to form the file. Hex editors that are designed to parse and edit sector data from the physical segments of floppy or hard disks are sometimes called sector editors or disk editors. A hex editor is used to see or edit the raw, exact contents of a file. Hex editors may used to correct data corrupted by a system or application. You can find an online hex editor at https://hexed.it/, or you can download one of the [many ones](https://en.wikipedia.org/wiki/Comparison_of_hex_editors) freely available.\n\n### Example\n\nOpen fileA.jpg in a hex editor. (Most Hex editors have either a “File \u003e Open” option or a simple drag and drop.)\n\n![fileA](/images/file-a-hex.jpg)\n\nWhen you open fileA.jpg in your hex editor, you should see something similar to this:\n\n![Hexadecimal Editor Screenshot](/images/hex-editor.png)\n\nYour hex editor should also have a “go to” or “find” feature so you can jump to a specific byte.","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/forensics/what-is-disk-imaging":{"title":"What is disk imaging?","content":"\nA forensic image is an electronic copy of a drive (e.g. a hard drive, USB, etc.). It’s a bit-by-­bit or bitstream file that’s an exact, unaltered copy of the media being duplicated.\n\nWikipedia said that the most straight­forward disk imaging method is to read a disk from start to finish and write the data to a forensics image format. “This can be a time-consuming process, especially for disks with a large capacity,” Wikipedia said.\n\nTo prevent write access to the disk, you can use a write blocker. It’s also common to calculate a cryptographic hash of the entire disk when imaging it. “Commonly-used cryptographic hashes are MD5, SHA1 and/or SHA256,” said Wikipedia. “By recalculating the integrity hash at a later time, one can determine if the data in the disk image has been changed. This by itself provides no protection against intentional tampering, but it can indicate that the data was altered, e.g. due to corruption.”\n\nWhy image a disk? Forensic imaging:\n- Prevents tampering with the original data­ evidence\n- Allows you to play around with the copy, without worrying about messing up the original\n\n## Forensic Image Extraction Exmple\n\nThis example uses the tool [AccessData FTK Imager](http://accessdata.com/product-download).\n\n**Step 1**: Go to `File \u003e Create Disk Image`\n\n![File Image Demo](/images/image-demo-1.png)\n\n**Step 2**: Select `Physical Drive`, because the USB or hard drive you’re imaging is a physical device or drive.\n\n![File Image Demo](/images/image-demo-2.png)\n\n**Step 3**: Select the drive you’re imaging. The 1000 GB is my computer hard drive; the 128 MB is the USB that I want to image.\n\n![File Image Demo](/images/image-demo-3.png)\n\n**Step 4**: Add a new image destination\n\n![File Image Demo](/images/image-demo-4.png)\n\n**Step 5**: Select whichever image type you want. Choose `Raw (dd)` if you’re a beginner, since it’s the most common type\n\n![File Image Demo](/images/image-demo-5.png)\n\n**Step 6**: Fill in all the evidence information\n\n![File Image Demo](/images/image-demo-6.png)\n\n**Step 7**: Choose where you want to store it\n\n![File Image Demo](/images/image-demo-7.png)\n\n**Step 8**: The image destination has been added. Now you can start the image extraction\n\n![File Image Demo](/images/image-demo-8.png)\n\n**Step 9**: Wait for the image to be extracted\n\n![File Image Demo](/images/image-demo-9.png)\n\n**Step 10**: This is the completed extraction\n\n![File Image Demo](/images/image-demo-10.png)\n\n**Step 11**: Add the image you just created so that you can view it\n\n![File Image Demo](/images/image-demo-11.png)\n\n**Step 12**: This time, choose image file, since that’s what you just created\n\n![File Image Demo](/images/image-demo-12.png)\n\n**Step 13**: Enter the path of the image you just created\n\n![File Image Demo](/images/image-demo-13.png)\n\n**Step 14**: View the image.\n\n1. Evidence tree\nStructure of the drive image\n2. File list\nList of all the files in the drive image folder\n3. Properties\nProperties of the file/folder being examined\n4. Hex viewer\nView of the drive/folders/files in hexadecimal\n\n![File Image Demo](/images/image-demo-14.png)\n\n**Step 15**: To view files in the USB, go to `Partition 1 \u003e [USB name] \u003e [root]` in the Evidence Tree and look in the File List\n\n![File Image Demo](/images/image-demo-15.png)\n\n**Step 16**: Selecting fileA, fileB, fileC, or fileD gives us some properties of the files \u0026 a preview of each photo\n\n![File Image Demo](/images/image-demo-16.png)\n\n**Step 17**: Extract files of interest for further analysis by selecting, right-clicking and choosing `Export Files`\n\n![File Image Demo](/images/image-demo-17.png)","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/forensics/what-is-memory-forensics":{"title":"What is memory forensics?","content":"\nThere are plenty of traces of someone's activity on a computer, but perhaps some of the most valuble information can be found within memory dumps, that is images taken of RAM. These dumps of data are often very large, but can be analyzed using a tool called [Volatility](http://www.volatilityfoundation.org/)\n\n## Volatility Basics\n\nMemory forensics isn't all that complicated, the hardest part would be using your toolset correctly. A good workflow is as follows:\n\n0. Run `strings` for clues\n1. Identify the image profile (which OS, version, etc.)\n2. Dump processes and look for suspicious processes\n3. Dump data related interesting processes\n4. View data in a format relating to the process (Word: docx, Notepad: txt, Photoshop: psd, etc.)\n\n### Profile Identification\n\nIn order to properly use Volatility you must supply a profile with `--profile=PROFILE`, therefore before any sleuthing, you need to determine the profile using imageinfo:\n\n```bash\n$ python vol.py -f ~/image.raw imageinfo\nVolatility Foundation Volatility Framework 2.4\nDetermining profile based on KDBG search...\n\n          Suggested Profile(s) : Win7SP0x64, Win7SP1x64, Win2008R2SP0x64, Win2008R2SP1x64\n                     AS Layer1 : AMD64PagedMemory (Kernel AS)\n                     AS Layer2 : FileAddressSpace (/Users/Michael/Desktop/win7_trial_64bit.raw)\n                      PAE type : PAE\n                           DTB : 0x187000L\n                          KDBG : 0xf80002803070\n          Number of Processors : 1\n     Image Type (Service Pack) : 0\n                KPCR for CPU 0 : 0xfffff80002804d00L\n             KUSER_SHARED_DATA : 0xfffff78000000000L\n           Image date and time : 2012-02-22 11:29:02 UTC+0000\n     Image local date and time : 2012-02-22 03:29:02 -0800\n```\n\n### Dump Processes\n\nIn order to view processes, the `pslist` or `pstree` or `psscan` command can be used.\n\n```bash\n$ python vol.py -f ~/image.raw pslist --profile=Win7SP0x64 pstree\nVolatility Foundation Volatility Framework 2.5\nOffset(V)          Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                          Exit\n------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------\n0xffffa0ee12532180 System                    4      0    108        0 ------      0 2018-04-22 20:02:33 UTC+0000\n0xffffa0ee1389d040 smss.exe                232      4      3        0 ------      0 2018-04-22 20:02:33 UTC+0000\n...\n0xffffa0ee128c6780 VBoxTray.exe           3324   1123     10        0      1      0 2018-04-22 20:02:55 UTC+0000\n0xffffa0ee14108780 OneDrive.exe           1422   1123     10        0      1      1 2018-04-22 20:02:55 UTC+0000\n0xffffa0ee14ade080 svchost.exe             228    121      1        0      1      0 2018-04-22 20:14:43 UTC+0000\n0xffffa0ee1122b080 notepad.exe            2019   1123      1        0      1      0 2018-04-22 20:14:49 UTC+0000\n```\n\n### Process Memory Dump\n\nDumping the memory of a process can prove to be fruitful, say we want to dump the data from notepad.exe:\n\n```bash\n$ python vol.py -f ~/image.raw --profile=Win7SP0x64 memdump -p 2019 -D dump/\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\nWriting System [     2019] to 2019.dmp\n\n$ ls -alh dump/2019.dmp\n-rw-r--r--  1 user  staff   111M Apr 22 20:47 dump/2019.dmp\n```\n\n### Other Useful Commands\n\n[There are plenty of commands](https://github.com/volatilityfoundation/volatility/wiki/Command-Reference) that Volatility offers but some highlights include:\n\n- `$ python vol.py -f IMAGE --profile=PROFILE connections`: view network connections\n- `$ python vol.py -f IMAGE --profile=PROFILE cmdscan`: view commands that were run in cmd prompt","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/forensics/what-is-metadata":{"title":"What is metadata?","content":"\nMetadata is data about data. Different types of files have different metadata. The metadata on a photo could include dates, camera information, GPS location, comments, etc. For music, it could include the title, author, track number and album.\n\n## What kind of file metadata is useful?\n\nPotentially, any file metadata you can find could be useful.\n\n## How do I find it?\n\n!!!note\n\tEXIF Data is metadata attached to photos which can include location, time, and device information.\n\nOne of our favorite tools is exiftool, which displays metadata for an input file, including:\n- File size\n- Dimensions (width and height)\n- File type\n- Programs used to create (e.g. Photoshop)\n- OS used to create (e.g. Apple)\n\nRun command line: `exiftool(-k).exe [filename]` and you should see something like this:\n\n![Exiftool](/images/exiftool.png)\n\n## Example\n\nLet's take a look at File A's metadata with exiftool: \n\nFile type\n\n![Metadata 1](/images/file-a-metadata-1.png)\n\nImage description\n\n![Metadata 2](/images/file-a-metadata-2.png)\n\nMake and camera info\n\n![Metadata 3](/images/file-a-metadata-3.png)\n\nGPS Latitude/Longitude\n\n![Metadata 4](/images/file-a-metadata-4.png)\n\n\n## Timestamps\n\nTimestamps are data that indicate the time of certain events (MAC):\n- Modification – when a file was modified\n- Access – when a file or entries were read or accessed\n- Creation – when files or entries were created\n\n### Types of timestamps\n- Modified\n- Accessed\n- Created\n- Date Changed (MFT)\n- Filename Date Created (MFT)\n- Filename Date Modified (MFT)\n- Filename Date Accessed (MFT)\n- INDX Entry Date Created\n- INDX Entry Date Modified\n- INDX Entry Date Accessed\n- INDX Entry Date Changed\n\n### Why do we care?\nCertain events such as creating, moving, copying, opening, editing, etc. might affect the MAC times. If the MAC timestamps can be attained, a timeline of events could be created.\n\n### Timeline Patterns\nThere are plenty more patterns than the ones introduced below, but these are the basics you should start with to get a good understanding of how it works, and to complete this challenge.\n\n![Timeline 1](/images/timeline-1.png)\n![Timeline 2](/images/timeline-2.png)\n![Timeline 3](/images/timeline-3.png)\n![Timeline 4](/images/timeline-4.png)\n![Timeline 5](/images/timeline-5.png)\n\n### Examples\n\nWe know that the BMP files fileA and fileD are the same, but that the JPEG files fileB and fileC are different somehow. So how can we find out what went on with these files?\n\n![Files A, B, C, D](/images/file-a-b-c-d.png)\n\nBy using time stamp information from the file system, we can learn that the BMP fileD was the original file, with fileA being a copy of the original. Afterward, fileB was created by modifying fileB, and fileC was created by modifying fileA in a different way.\n\nFollow along as we demonstrate.\n\nWe’ll start by analyzing images in AccessData FTK Imager, where there’s a Properties window that shows you some information about the file or folder you’ve selected.\n\n![Timestamp 1](/images/timestamp-1.png)\n![Timestamp 2](/images/timestamp-2.png)\n![Timestamp 3](/images/timestamp-3.png)\n![Timestamp 4](/images/timestamp-4.png)\n\nHere are the extracted MAC times for fileA, fileB, fileC and fileD:\n*Note, AccessData FTK Imager assumes that the file times on the drive are in UTC (Universal Coordinated Time). I subtracted four hours, since the USB was set up in Eastern Standard Time. This isn’t necessary, but it helps me understand the times a bit better.*\n\n![Timestamp 5](/images/timestamp-5.png)\n\nHighlight timestamps that are the same, if timestamps are off by a few seconds, they should be counted as the same. This lets you see a clear difference between different timestamps. Then, highlight oldest to newest to help put them in order.\n\n![Timestamp 6](/images/timestamp-6.png)\n![Timestamp 7](/images/timestamp-7.png)\n![Timestamp 8](/images/timestamp-8.png)\n![Timestamp 9](/images/timestamp-9.png)\n![Timestamp 10](/images/timestamp-10.png)\n![Timestamp 11](/images/timestamp-11.png)\n![Timestamp 12](/images/timestamp-12.png)\n![Timestamp 13](/images/timestamp-13.png)\n![Timestamp 14](/images/timestamp-14.png)\n![Timestamp 15](/images/timestamp-15.png)\n\n\nIdentify timestamp patterns.\n\n![Timestamp 16](/images/timestamp-16.png)\n","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/forensics/what-is-steganography":{"title":"What is steganography?","content":"\nStegonagraphy is the practice of hiding data in plain sight. Stegonagraphy is often embedded in images or audio.\n\nYou could send a picture of a cat to a friend and hide text inside. Looking at the image, there’s nothing to make anyone think there’s a message hidden inside it.\n\n![Steg with text](/images/steg-cat-text.png)\n\nYou could also hide a second image inside the first.\n\n![Steg with an Image](/images/steg-cat-image.png)\n\n## Stegonagraphy Detection\n\nSo we can hide text and an image, how do we find out if there is hidden data?\n\n![Group of images](/images/steg-a-b-c-d.png)\n\nFileA and FileD appear the same, but they’re different. Also, FileD was modified after it was copied, so it’s possible there might be steganography in it.\n\nFileB and FileC don’t appear to have been modified after being created. That doesn’t rule out the possibility that there’s steganography in them, but you’re more likely to find it in fileD. This brings up two questions:\n\n1. Can we determine that there is steganography in fileD?\n2. If there is, what was hidden in it?\n\n## LSB Stegonagraphy\n\nFile are made of bytes. Each byte is composed of eight bits.\n\n![Steganography Process Step 1](/images/steg-step-1.png)\n\nChanging the least-significant bit (LSB) doesn’t change the value very much.\n\n![Steganography Process Step 2](/images/steg-step-2.png)\n\nSo we can modify the LSB without changing the file noticeably. By doing so, we can hide a message inside.\n\n### LSB Stegonagraphy in Images\n\nLSB Stegonagraphy or *Least Significant Bit* Stegonagraphy is a method of stegonagraphy where data is recorded in the lowest bit of a byte.\n\nSay an image has a pixel with an RGB value of (255, 255, 255), the bits of those RGB values will look like\n\n| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n\nBy modifying the lowest, or least significant, bit, we can use the 1 bit space across every RGB value for every pixel to construct a message.\n\n| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n\nThe reason stegonagraphy is hard to detect by sight is because a 1 bit difference in color is insignificant as seen below.\n\n![1 Bit Difference](/images/lsb-color-difference.png)\n\n### Example\n\nLet’s say we have an image, and part of it contains the following binary:\n\n![Steganography Process Step 3](/images/steg-step-3.png)\n\nAnd let’s say we want to hide the character y inside.\n\nFirst, we need to convert the hidden message to binary.\n\n![Steganography Process Step 4](/images/steg-step-4.png)\n\nNow we take each bit from the hidden message and replace the LSB of the corresponding byte with it.\n\n![Steganography Process Step 5](/images/steg-step-5.png)\n\nAnd again:\n\n![Steganography Process Step 6](/images/steg-step-6.png)\n\nAnd again:\n\n![Steganography Process Step 7](/images/steg-step-7.png)\n\nAnd again:\n\n![Steganography Process Step 8](/images/steg-step-8.png)\n\nAnd again:\n\n![Steganography Process Step 9](/images/steg-step-9.png)\n\nAnd again:\n\n![Steganography Process Step 10](/images/steg-step-10.png)\n\nAnd again:\n\n![Steganography Process Step 11](/images/steg-step-11.png)\n\nAnd once more:\n\n![Steganography Process Step 12](/images/steg-step-12.png)\n\nDecoding LSB steganography is exactly the same as encoding, but in reverse. For each byte, grab the LSB and add it to your decoded message. Once you’ve gone through each byte, convert all the LSBs you grabbed into text or a file. (You can use your file signature knowledge here!)\n\n## Audio Steganography\n\nLSB Steganography can be used for more than just images; it can also be used for audio files! Another popular technique is to hide text in the spectrogram of an audio file. This shown below:\n\n![Spectrogram](/images/spectrogram.png)\n\n## What other types of steganography are there?\nSteganography is hard for the defense side, because there’s practically an infinite number of ways it could be carried out. Here are a few examples:\n- LSB steganography: different bits, different bit combinations\n- Encode in every certain number of bytes \n- Use a password\n- Hide in different places\n- Use encryption on top of steganography","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/forensics/what-is-wireshark":{"title":"What is wireshark?","content":"\n[Wireshark](http://www.wireshark.com) is a network protocol analyzer which is often used in CTF challenges to look at recorded network traffic. Wireshark uses a filetype called PCAP to record traffic. PCAPs are often distributed in CTF challenges to provide recorded traffic history.\n\n## Interface\n\nUpon opening Wireshark, you are greeted with the option to open a PCAP or begin capturing network traffic on your device.\n\n![Wirshark Start Screen](/images/ws-start-screen.png)\n\nThe network traffic displayed initially shows the packets in order of which they were captured. You can filter packets by protocol, source IP address, destination IP address, length, etc. \n\n![PCAP Screen](/images/ws-pcap-screen.png)\n\nIn order to apply filters, simply enter the constraining factor, for example 'http', in the display filter bar. \n\n![PCAP HTTP Filter](/images/ws-filter.png)\n\nFilters can be chained together using '\u0026\u0026' notation. In order to filter by IP, ensure a double equals '==' is used. \n\n![PCAP HTTP IP Filter](/images/ws-filter-2.png)\n\nThe most pertinent part of a packet is its data payload and protocol information.\n\n![HTTP TCP Info](/images/ws-tcp-http-info.png)\n\n## Decrypting SSL Traffic\n\nBy default, Wireshark cannot decrypt SSL traffic on your device unless you grant it specific certificates.\n\n### High Level SSL Handshake Overview\n\nIn order for a network session to be encrypted properly, the client and server must share a common secret for which they can use to encrypt and decrypt data without someone in the middle being able to guess. The SSL Handshake loosely follows this format:\n\n1. The client sends a list of availble cipher suites it can use along with a random set of bytes referred to as client_random\n2. The server sends back the cipher suite that will be used, such as TLS_DHE_RSA_WITH_AES_128_CBC_SHA, along with a random set of bytes referred to as server_random\n3. The client generates a pre-master secret, encrypts it, then sends it to the server.\n4. The server and client then generate a common master secret using the selected cipher suite\n5. The client and server begin communicating using this common secret\n\n### Decryption Requirements\n\nThere are several ways to be able to decrypt traffic.\n\n- If you have the client and server random values *and* the pre-master secret, the master secret can be generated and used to decrypt the traffic\n- If you have the master secret, traffic can be decrypted easily\n- If the cipher-suite uses RSA, you can factor *n* in the key in order to break the encryption on the encrypted pre-master secret and generate the master secret with the client and server randoms \n\n![Wireshark SSL Preferences](/images/ws-ssl-pref.png)","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/general":{"title":"General Resources","content":"\n - https://ctfs.github.io/resources/\n - https://github.com/swisskyrepo/PayloadsAllTheThings\n - https://ctf101.org\n - https://ctf-wiki.mahaloz.re/ (very extensive)\n - https://book.hacktricks.xyz/\n ","lastmodified":"2023-12-02T07:08:59.584077898Z","tags":null},"/linux/intro":{"title":"Linux Intro","content":"\n## What is Linux?\nLinux is an operating system, just like Windows or Mac OS. It is a free and open source operating system, meaning that anyone can use it, modify it, and distribute it. Linux is used on many different devices, including servers, desktops, and even phones. Linux is also used in many different places, including NASA, the US Department of Defense, and even the International Space Station. In cybersecurity, Linux is used to host servers, and to run tools that are used to solve challenges.\n\n## Executing Commands\nIn Linux, commands are executed in the terminal. The terminal is a program that allows you to execute commands. The terminal is also known as the command line interface (CLI). Some example commands are `ls`, `cd`, and `pwd`. These commands are used to list files, change directories, and print the working directory, respectively. The terminal is also used to execute programs. For example, the command `python3` is used to execute the Python 3 interpreter. The terminal is also used to install programs. For example, the command `sudo apt install python3` is used to install Python 3.\n\n## Learn More\nLinux takes a while to learn, but it is worth it. If you want to learn more about Linux, you can check out the following resources:\n* [Linux Journey](https://linuxjourney.com/)\n* [Linux Command Line Basics](https://www.youtube.com/watch?v=oxuRxtrO2Ag)\n* [Linux Command Line Basics 2](https://www.youtube.com/watch?v=HbgzrKJvDRw)\n* [Linux Command Line Basics 3](https://www.youtube.com/watch?v=JfXVhj0jIqQ)\n* [Linux Command Line Basics 4](https://www.youtube.com/watch?v=5XgBd6rjuDQ)\n* [Linux Command Line Basics 5](https://www.youtube.com/watch?v=1uFYk0Eo7D0)\n\n","lastmodified":"2023-12-02T07:08:59.628078439Z","tags":null},"/programming/intro":{"title":"Programming Intro","content":"\nProgramming is a vast field, and there are many different languages and tools that can be used to solve challenges. In this section, we will learn about the basics of programming, and how to use the programming tools that are used in CTFs. \n\n## Python\n\nPython is typically used to solve challenges in CTFs because it is easy to learn, and it is very powerful. Python is an interpreted language, meaning that it is not compiled into machine code. Instead, it is interpreted by a Python interpreter. Python is also an object-oriented language, meaning that it uses objects to represent data. Python is also a high-level language, meaning that it is easy to read and write.\n\nProgramming can be both easy to learn, but also very challenging. Like learning another spoken language, it takes time to pick up the vocabulary and learn the grammar. Fortunately there's a wealth of resources to help you learn and once you've cracked it the results are phenomenal. Just remember: you'll need to be persistent.\n\nDeveloping solid programming skills isn't going to happen overnight or by reading a book (or this Field Manual!) and watching a few videos. You need to get your hands dirty! You need to write code to learn code. You'll write code that doesn't work, debug it, fix it, and break it again many times. It's through these problems and interesting bugs you'll encounter that you gain a better understanding and your skills improve. Plus, finally fixing that error you've been struggling with for the last hour can be super satisfying!\n\nSo what kind of things could you do with these new programming skills? Well, let's say you have a zip file secured with a password, but you can't quite remember what it is. You could write a simple program to iterate and try a bunch of passwords instead of doing it manually. You could create a program to scrape content from websites to gather open source intelligence for a pentest you're working on. Or perhaps you need to be able to encrypt data and transmit it between two systems using sound! Programming opens up a world of creativity and possibilities.\n\n## Running Python Programs\n\nTo run a python program, you need to have Python installed on your computer. You can download Python from the [Python website](https://www.python.org/downloads/). Once you have Python installed, you can run a Python program by opening a terminal and running the command `python3 \u003cfilename\u003e`. For example, if you have a file called `hello.py`, you can run it by running the command `python3 hello.py`.\n\n## Python Syntax\n\nThe syntax of a programming language is the set of rules that defines how a program is written. The syntax of Python is very simple, and it is similar to English. For example, the following code prints the text \"Hello, World!\" to the terminal:\n\n```python\nprint(\"Hello, World!\")\n```\n\n## Variables\n\nVariables are used to store data. For example, the following code stores the text \"Hello, World!\" in a variable called `message`:\n\n```python\nmessage = \"Hello, World!\"\n```\n\nVariables can store many different types of data. For example, the following code stores the number `42` in a variable called `number`:\n\n```python\nnumber = 42\n```\n\n## Data Types\n\nThere are many different types of data that can be stored in variables. The most common data types are strings, integers, and floats. Strings are used to store text. Integers are used to store whole numbers. Floats are used to store decimal numbers. For example, the following code stores the text \"Hello, World!\" in a variable called `message`, the number `42` in a variable called `number`, and the decimal number `3.14` in a variable called `pi`:\n\n```python\nmessage = \"Hello, World!\"\nnumber = 42\npi = 3.14\n```\n\n## Lists\n\nLists are used to store multiple values in a single variable. For example, the following code stores the numbers `1`, `2`, and `3` in a variable called `numbers`:\n\n```python\nnumbers = [1, 2, 3]\n```\n\n## Dictionaries\n\nDictionaries are used to store key-value pairs. For example, the following code stores the key-value pairs `name: John` and `age: 42` in a variable called `person`:\n\n```python\nperson = {\n    \"name\": \"John\",\n    \"age\": 42\n}\n```\n\n## Tuples \n\nTuples are used to store multiple values in a single variable, just like lists. However, tuples are immutable, meaning that they cannot be changed. For example, the following code stores the numbers `1`, `2`, and `3` in a variable called `numbers`:\n\n```python\nnumbers = (1, 2, 3)\n```\n\n## Functions\n\nFunctions are used to perform a specific task. For example, the following code defines a function called `hello` that prints the text \"Hello, World!\" to the terminal:\n\n```python\ndef hello():\n    print(\"Hello, World!\")\n```\n\n## Conditionals\n\nConditionals are used to perform different actions based on different conditions. For example, the following code prints the text \"Hello, World!\" to the terminal if the variable `message` is equal to \"Hello, World!\":\n\n```python\nif message == \"Hello, World!\":\n    print(\"Hello, World!\")\n```\n\n## Loops\n\nLoops are used to repeat a block of code a certain number of times. For example, the following code prints the numbers `1`, `2`, and `3` to the terminal:\n\n```python\nfor number in [1, 2, 3]:\n    print(number)\n```\n\n## Reading and Writing Files\n\nPython can be used to read and write files. For example, the following code reads the contents of a file called `message.txt` and stores it in a variable called `message`:\n\n```python\nwith open(\"message.txt\", \"r\") as f:\n    message = f.read()\n```\n\nThe following code writes the text \"Hello, World!\" to a file called `message.txt`:\n\n```python\nwith open(\"message.txt\", \"w\") as f:\n    f.write(\"Hello, World!\")\n```\n\n## Learning More\nProgramming takes practice, and there is no substitute for actually writing code. However, there are many resources available to help you learn. The following resources are a good place to start for learning Python:\n* [Python Documentation](https://docs.python.org/3/)\n* [Python Tutorial](https://docs.python.org/3/tutorial/index.html)\n* [Python for Beginners](https://www.python.org/about/gettingstarted/)\n* [Automate the Boring Stuff with Python](https://automatetheboringstuff.com/)\n* [Codecademy](https://www.codecademy.com/learn/learn-python)\n* [Learn Python](https://www.learnpython.org/)\n","lastmodified":"2023-12-02T07:08:59.628078439Z","tags":null}}